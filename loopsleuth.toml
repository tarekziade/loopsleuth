# LoopSleuth Performance Checks Configuration
#
# This file defines the performance checks that LoopSleuth runs on Python code.
# You can customize checks, add new ones, or modify existing prompts.

[settings]
# Default CLI options (all are optional and can be overridden by CLI flags)
# model = "./models/qwen2.5-coder-3b-instruct-q4_k_m.gguf"  # Path to GGUF model
# threads = 4                                                 # Number of inference threads
# max_tokens = 1024                                           # Maximum tokens to generate (increased for detailed diffs)
# context_size = 4096                                         # Context window size
# skip_large = 0                                              # Skip functions larger than N lines
# cache_dir = ".loopsleuth_cache"                             # Cache directory path

[[check]]
key = "quadratic"
name = "Quadratic Complexity"
description = "Detects O(n²) or worse time complexity patterns (nested loops, etc.)"
category = "performance"
keyword = "QUADRATIC"
detection_prompt = """<|im_start|>system
You are a strict performance check. You MUST follow the output format exactly.

Rules:
- Output must be exactly 4 lines: VERDICT, CONFIDENCE, DETAIL, END.
- VERDICT must be either: "VERDICT: OK" OR "VERDICT: QUADRATIC" (use the check keyword EXACTLY).
- CONFIDENCE must be a float 0.00-1.00.
- DETAIL must cite concrete code tokens/operations from the function (e.g., "list.index() in loop", "nested loops over same data").
- If uncertain, output VERDICT: OK with lower confidence.
- Do NOT include any other text.

Look for these quadratic patterns:
1. Nested loops iterating over the same or related data structures
2. Linear operations inside loops: list.index(), x in list, list.remove()
3. Operations that are O(n) being called n times

Define symbols when relevant:
- N = number of items/tokens processed (dominant scaling dimension)
Only label QUADRATIC if runtime is Ω(N^2) or worse with respect to N.

IMPORTANT: Nested loops alone are NOT quadratic unless they iterate over related data.
- QUADRATIC: for i in items: for j in items: (same data)
- QUADRATIC: for item in items: idx = list.index(item) (O(n) in O(n) loop)
- NOT QUADRATIC: for i in batch: for j in features: (independent dimensions)

<|im_end|>
<|im_start|>user
Check "Quadratic Complexity" with keyword "QUADRATIC".

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
solution_prompt = """<|im_start|>system
You are an expert performance engineer. Fix the quadratic complexity issue by outputting the COMPLETE optimized function.

STEP-BY-STEP FIX FOR `list.index(x)` IN LOOP:

Step 1: Identify the O(n) operation in the loop
- Look for: `.index()` call on a list/sequence
- This is O(n) because it scans the entire list each time

Step 2: Pre-compute a lookup dictionary BEFORE the loop
- Add this line BEFORE the loop starts:
  `variable_to_index = {value: index for index, value in enumerate(the_list)}`
- Use a descriptive name, not just 'd' or 'dict'

Step 3: Replace the .index() call with dictionary lookup
- Change: `idx = the_list.index(item)`
- To: `idx = variable_to_index[item]`
- Remove the `.index()` call completely - do NOT keep it

EXAMPLE:
```python
# ORIGINAL (with performance issue):
def process_items(items, reference_list):
    results = []
    for item in items:
        idx = reference_list.index(item)  # ❌ O(n) - BAD
        results.append(idx)
    return results

# OPTIMIZED (your output should look like this):
def process_items(items, reference_list):
    # Pre-build lookup dictionary to avoid O(n) .index() calls in loop
    ref_to_index = {value: idx for idx, value in enumerate(reference_list)}

    results = []
    for item in items:
        idx = ref_to_index[item]  # ✅ O(1) - GOOD
        results.append(idx)
    return results
```

CRITICAL REQUIREMENTS:
- Output the COMPLETE optimized function inside ```python fenced block
- Do NOT output a diff - output the full fixed function
- Do NOT keep the .index() call - REPLACE it with dict lookup
- Do NOT add error handling unless the original had it
- Use clear variable names (e.g., `aspect_ratio_to_id`, not `d`)
- Add a brief comment explaining the optimization
- Keep the exact function signature (def line with all parameters and type hints)
- Preserve all other logic exactly as-is

<|im_end|>
<|im_start|>user
Issue keyword: QUADRATIC

Function to optimize:
```python
{function_source}
```

Output the COMPLETE optimized version of this function. Remember:
1. Find the .index() or other O(n) operation
2. Pre-build a lookup dict BEFORE the loop
3. REPLACE the O(n) operation with O(1) dict lookup
4. Output the FULL function in ```python block

<|im_end|>
<|im_start|>assistant
```python
"""
verifier_prompt = """<|im_start|>system
You are a strict patch verifier.

Input:
- ORIGINAL FUNCTION
- PROPOSED DIFF

Output exactly:
VERDICT: VALID | INVALID
REASON: <one short reason, concrete>
END

INVALID if:
- diff block missing
- removed lines do not exist in original
- introduces syntax errors (obvious)
- references undefined variables
- changes meaning in risky ways (e.g. index_add_ -> += with potentially duplicate indices)

Do not add anything else.
<|im_end|>
<|im_start|>user
Original function:
```python
{function_source}
```

Proposed solution:
{solution}

Is this valid? Output VERDICT:, REASON:, END.
<|im_end|>
<|im_start|>assistant
"""

[[check]]
key = "linear-in-loop"
name = "Linear Operations in Loops"
description = "Detects hidden O(n) operations in loops (list.remove(), x in list, etc.)"
category = "performance"
keyword = "LINEAR_IN_LOOP"
detection_prompt = """<|im_start|>system
You are a strict performance check. You MUST follow the output format exactly.

Rules:
- Output must be exactly 4 lines: VERDICT, CONFIDENCE, DETAIL, END.
- VERDICT must be either: "VERDICT: OK" OR "VERDICT: LINEAR_IN_LOOP" (use the check keyword EXACTLY).
- CONFIDENCE must be a float 0.00-1.00.
- DETAIL must cite concrete code tokens/operations from the function (e.g., "x in list", "list.remove()", "list.index()").
- If uncertain, output VERDICT: OK with lower confidence.
- Do NOT include any other text.

Look for these patterns in loops:
- `x in list` membership tests (O(n) per check)
- `list.remove(x)` operations (O(n) per removal)
- `list.index(x)` lookups (O(n) per lookup)
- `list.pop(0)` from front of list (O(n) per pop)
- String concatenation with += in loops

<|im_end|>
<|im_start|>user
Check "Linear Operations in Loops" with keyword "LINEAR_IN_LOOP".

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
solution_prompt = """<|im_start|>system
You are an expert performance engineer. Produce a minimal, correct patch.

Hard constraints:
- Output MUST contain exactly one ```diff fenced block and nothing else.
- The diff must apply to the provided function as-is.
- Do NOT reference variables that are not defined in the shown context.
- Do NOT introduce syntax errors.
- Do NOT change semantics unless explicitly required by the issue (e.g. do not replace index_add_ with += if indices may repeat).
- If a safe fix is not possible without larger refactor, output an empty diff that changes only a comment explaining why.

<|im_end|>
<|im_start|>user
Issue keyword: LINEAR_IN_LOOP

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
verifier_prompt = """<|im_start|>system
You are a strict patch verifier.

Input:
- ORIGINAL FUNCTION
- PROPOSED DIFF

Output exactly:
VERDICT: VALID | INVALID
REASON: <one short reason, concrete>
END

INVALID if:
- diff block missing
- removed lines do not exist in original
- introduces syntax errors (obvious)
- references undefined variables
- changes meaning in risky ways (e.g. index_add_ -> += with potentially duplicate indices)

Do not add anything else.
<|im_end|>
<|im_start|>user
Original function:
```python
{function_source}
```

Proposed solution:
{solution}

Is this valid? Output VERDICT:, REASON:, END.
<|im_end|>
<|im_start|>assistant
"""

[[check]]
key = "expensive-sort-key"
name = "Expensive Sort Key"
description = "Detects O(n) key functions in sort/sorted operations"
category = "performance"
keyword = "EXPENSIVE_SORT_KEY"
detection_prompt = """<|im_start|>system
You are a strict performance check. You MUST follow the output format exactly.

Rules:
- Output must be exactly 4 lines: VERDICT, CONFIDENCE, DETAIL, END.
- VERDICT must be either: "VERDICT: OK" OR "VERDICT: EXPENSIVE_SORT_KEY" (use the check keyword EXACTLY).
- CONFIDENCE must be a float 0.00-1.00.
- DETAIL must cite concrete code tokens/operations from the function (e.g., "key=lambda x: list.index(x)", "key=lambda x: x in other_list").
- If uncertain, output VERDICT: OK with lower confidence.
- Do NOT include any other text.

Look for sort/sorted with key functions that are O(n):
- `key=lambda x: list.index(x)` - O(n) lookup per comparison
- `key=lambda x: x in other_list` - O(n) membership test
- `key=lambda x: re.match(pattern, x)` - expensive regex per comparison

<|im_end|>
<|im_start|>user
Check "Expensive Sort Key" with keyword "EXPENSIVE_SORT_KEY".

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
solution_prompt = """<|im_start|>system
You are an expert performance engineer. Produce a minimal, correct patch.

Hard constraints:
- Output MUST contain exactly one ```diff fenced block and nothing else.
- The diff must apply to the provided function as-is.
- Do NOT reference variables that are not defined in the shown context.
- Do NOT introduce syntax errors.
- Do NOT change semantics unless explicitly required by the issue (e.g. do not replace index_add_ with += if indices may repeat).
- If a safe fix is not possible without larger refactor, output an empty diff that changes only a comment explaining why.

<|im_end|>
<|im_start|>user
Issue keyword: EXPENSIVE_SORT_KEY

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
verifier_prompt = """<|im_start|>system
You are a strict patch verifier.

Input:
- ORIGINAL FUNCTION
- PROPOSED DIFF

Output exactly:
VERDICT: VALID | INVALID
REASON: <one short reason, concrete>
END

INVALID if:
- diff block missing
- removed lines do not exist in original
- introduces syntax errors (obvious)
- references undefined variables
- changes meaning in risky ways (e.g. index_add_ -> += with potentially duplicate indices)

Do not add anything else.
<|im_end|>
<|im_start|>user
Original function:
```python
{function_source}
```

Proposed solution:
{solution}

Is this valid? Output VERDICT:, REASON:, END.
<|im_end|>
<|im_start|>assistant
"""

[[check]]
key = "unbounded-alloc"
name = "Unbounded Allocations"
description = "Detects growing allocations in loops (string concat, repeated cat)"
category = "performance"
keyword = "UNBOUNDED_ALLOC"
detection_prompt = """<|im_start|>system
You are a strict performance check. You MUST follow the output format exactly.

Rules:
- Output must be exactly 4 lines: VERDICT, CONFIDENCE, DETAIL, END.
- VERDICT must be either: "VERDICT: OK" OR "VERDICT: UNBOUNDED_ALLOC" (use the check keyword EXACTLY).
- CONFIDENCE must be a float 0.00-1.00.
- DETAIL must cite concrete code tokens/operations from the function (e.g., "result += str", "torch.cat()", "result = result + [item]").
- If uncertain, output VERDICT: OK with lower confidence.
- Do NOT include any other text.

ONLY flag these TRUE unbounded allocation patterns:
- String concatenation with += in loops (creates new string each iteration)
- Repeated list/array concatenation (e.g., `result = result + [item]`)
- `torch.cat()` or `np.concatenate()` repeatedly called in loops

DO NOT flag (they are SAFE):
- Bounded loops like `for i in range(n)` where n is fixed
- Appending to a list (e.g., `list.append(x)`)
- Counter increments (e.g., `count += 1`)

<|im_end|>
<|im_start|>user
Check "Unbounded Allocations" with keyword "UNBOUNDED_ALLOC".

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
solution_prompt = """<|im_start|>system
You are an expert performance engineer. Produce a minimal, correct patch.

Hard constraints:
- Output MUST contain exactly one ```diff fenced block and nothing else.
- The diff must apply to the provided function as-is.
- Do NOT reference variables that are not defined in the shown context.
- Do NOT introduce syntax errors.
- Do NOT change semantics unless explicitly required by the issue (e.g. do not replace index_add_ with += if indices may repeat).
- If a safe fix is not possible without larger refactor, output an empty diff that changes only a comment explaining why.

<|im_end|>
<|im_start|>user
Issue keyword: UNBOUNDED_ALLOC

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
verifier_prompt = """<|im_start|>system
You are a strict patch verifier.

Input:
- ORIGINAL FUNCTION
- PROPOSED DIFF

Output exactly:
VERDICT: VALID | INVALID
REASON: <one short reason, concrete>
END

INVALID if:
- diff block missing
- removed lines do not exist in original
- introduces syntax errors (obvious)
- references undefined variables
- changes meaning in risky ways (e.g. index_add_ -> += with potentially duplicate indices)

Do not add anything else.
<|im_end|>
<|im_start|>user
Original function:
```python
{function_source}
```

Proposed solution:
{solution}

Is this valid? Output VERDICT:, REASON:, END.
<|im_end|>
<|im_start|>assistant
"""

[[check]]
key = "conversion-churn"
name = "Conversion Churn"
description = "Detects repeated CPU/GPU or tensor/array conversions in loops"
category = "ml-specific"
keyword = "CONVERSION_CHURN"
detection_prompt = """<|im_start|>system
You are a strict performance check. You MUST follow the output format exactly.

Rules:
- Output must be exactly 4 lines: VERDICT, CONFIDENCE, DETAIL, END.
- VERDICT must be either: "VERDICT: OK" OR "VERDICT: CONVERSION_CHURN" (use the check keyword EXACTLY).
- CONFIDENCE must be a float 0.00-1.00.
- DETAIL must cite concrete code tokens/operations from the function (e.g., ".cpu()", ".cuda()", ".to(device)", ".numpy()").
- If uncertain, output VERDICT: OK with lower confidence.
- Do NOT include any other text.

Look for these patterns in loops:
- Repeated `.cpu()` or `.cuda()` or `.to(device)` calls
- Repeated `.numpy()` conversions from tensors
- Repeated `torch.tensor()` or `torch.from_numpy()` conversions
- Back-and-forth between CPU and GPU

<|im_end|>
<|im_start|>user
Check "Conversion Churn" with keyword "CONVERSION_CHURN".

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
solution_prompt = """<|im_start|>system
You are an expert performance engineer. Produce a minimal, correct patch.

Hard constraints:
- Output MUST contain exactly one ```diff fenced block and nothing else.
- The diff must apply to the provided function as-is.
- Do NOT reference variables that are not defined in the shown context.
- Do NOT introduce syntax errors.
- Do NOT change semantics unless explicitly required by the issue (e.g. do not replace index_add_ with += if indices may repeat).
- If a safe fix is not possible without larger refactor, output an empty diff that changes only a comment explaining why.

<|im_end|>
<|im_start|>user
Issue keyword: CONVERSION_CHURN

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
verifier_prompt = """<|im_start|>system
You are a strict patch verifier.

Input:
- ORIGINAL FUNCTION
- PROPOSED DIFF

Output exactly:
VERDICT: VALID | INVALID
REASON: <one short reason, concrete>
END

INVALID if:
- diff block missing
- removed lines do not exist in original
- introduces syntax errors (obvious)
- references undefined variables
- changes meaning in risky ways (e.g. index_add_ -> += with potentially duplicate indices)

Do not add anything else.
<|im_end|>
<|im_start|>user
Original function:
```python
{function_source}
```

Proposed solution:
{solution}

Is this valid? Output VERDICT:, REASON:, END.
<|im_end|>
<|im_start|>assistant
"""

[[check]]
key = "python-loop-over-token-dimension"
name = "Python Loop Over Token Dimension"
description = "Detects Python loops iterating over token/sequence dimensions in ML models"
category = "ml-specific"
keyword = "ML_LOOP_OVER_TOKENS"
detection_prompt = """<|im_start|>system
You are a strict performance check. You MUST follow the output format exactly.

Rules:
- Output must be exactly 4 lines: VERDICT, CONFIDENCE, DETAIL, END.
- VERDICT must be either: "VERDICT: OK" OR "VERDICT: ML_LOOP_OVER_TOKENS" (use the check keyword EXACTLY).
- CONFIDENCE must be a float 0.00-1.00.
- DETAIL must cite concrete code tokens/operations from the function (e.g., "for i in range(seq_len)", "for token in tensor", "len(tensor)").
- If uncertain, output VERDICT: OK with lower confidence.
- Do NOT include any other text.

Only flag if:
- Python loop iterates over a tensor dimension (len(tensor), tensor.shape[0], range(seq_len))
- Loop body operates on individual elements/tokens
- Should be vectorized instead

DO NOT flag:
- Loops over layers/experts (that's architectural)
- Loops for batching multiple sequences
- Single-use initialization code

<|im_end|>
<|im_start|>user
Check "Python Loop Over Token Dimension" with keyword "ML_LOOP_OVER_TOKENS".

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
solution_prompt = """<|im_start|>system
You are an expert performance engineer. Produce a minimal, correct patch.

Hard constraints:
- Output MUST contain exactly one ```diff fenced block and nothing else.
- The diff must apply to the provided function as-is.
- Do NOT reference variables that are not defined in the shown context.
- Do NOT introduce syntax errors.
- Do NOT change semantics unless explicitly required by the issue (e.g. do not replace index_add_ with += if indices may repeat).
- If a safe fix is not possible without larger refactor, output an empty diff that changes only a comment explaining why.

<|im_end|>
<|im_start|>user
Issue keyword: ML_LOOP_OVER_TOKENS

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
verifier_prompt = """<|im_start|>system
You are a strict patch verifier.

Input:
- ORIGINAL FUNCTION
- PROPOSED DIFF

Output exactly:
VERDICT: VALID | INVALID
REASON: <one short reason, concrete>
END

INVALID if:
- diff block missing
- removed lines do not exist in original
- introduces syntax errors (obvious)
- references undefined variables
- changes meaning in risky ways (e.g. index_add_ -> += with potentially duplicate indices)

Do not add anything else.
<|im_end|>
<|im_start|>user
Original function:
```python
{function_source}
```

Proposed solution:
{solution}

Is this valid? Output VERDICT:, REASON:, END.
<|im_end|>
<|im_start|>assistant
"""

[[check]]
key = "mask-built-in-layer-loop"
name = "Mask Built In Layer Loop"
description = "Detects attention masks being rebuilt inside per-layer loops"
category = "ml-specific"
keyword = "ML_MASK_IN_LOOP"
detection_prompt = """<|im_start|>system
You are a strict performance check. You MUST follow the output format exactly.

Rules:
- Output must be exactly 4 lines: VERDICT, CONFIDENCE, DETAIL, END.
- VERDICT must be either: "VERDICT: OK" OR "VERDICT: ML_MASK_IN_LOOP" (use the check keyword EXACTLY).
- CONFIDENCE must be a float 0.00-1.00.
- DETAIL must cite concrete code tokens/operations from the function (e.g., "torch.tril", "torch.ones", "mask creation in loop").
- If uncertain, output VERDICT: OK with lower confidence.
- Do NOT include any other text.

Only flag if:
- Attention mask created inside a loop over layers/blocks
- Same mask could be created once before loop
- Operations like torch.tril, torch.ones for causal mask

DO NOT flag:
- Mask used once (not in loop)
- Dynamic masks that change per iteration
- Mask creation outside loops

<|im_end|>
<|im_start|>user
Check "Mask Built In Layer Loop" with keyword "ML_MASK_IN_LOOP".

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
solution_prompt = """<|im_start|>system
You are an expert performance engineer. Produce a minimal, correct patch.

Hard constraints:
- Output MUST contain exactly one ```diff fenced block and nothing else.
- The diff must apply to the provided function as-is.
- Do NOT reference variables that are not defined in the shown context.
- Do NOT introduce syntax errors.
- Do NOT change semantics unless explicitly required by the issue (e.g. do not replace index_add_ with += if indices may repeat).
- If a safe fix is not possible without larger refactor, output an empty diff that changes only a comment explaining why.

<|im_end|>
<|im_start|>user
Issue keyword: ML_MASK_IN_LOOP

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
verifier_prompt = """<|im_start|>system
You are a strict patch verifier.

Input:
- ORIGINAL FUNCTION
- PROPOSED DIFF

Output exactly:
VERDICT: VALID | INVALID
REASON: <one short reason, concrete>
END

INVALID if:
- diff block missing
- removed lines do not exist in original
- introduces syntax errors (obvious)
- references undefined variables
- changes meaning in risky ways (e.g. index_add_ -> += with potentially duplicate indices)

Do not add anything else.
<|im_end|>
<|im_start|>user
Original function:
```python
{function_source}
```

Proposed solution:
{solution}

Is this valid? Output VERDICT:, REASON:, END.
<|im_end|>
<|im_start|>assistant
"""

[[check]]
key = "growing-container"
name = "Growing Containers"
description = "Detects loops that grow containers while iterating"
category = "performance"
keyword = "GROWING_CONTAINER"
detection_prompt = """<|im_start|>system
You are a strict performance check. You MUST follow the output format exactly.

Rules:
- Output must be exactly 4 lines: VERDICT, CONFIDENCE, DETAIL, END.
- VERDICT must be either: "VERDICT: OK" OR "VERDICT: GROWING_CONTAINER" (use the check keyword EXACTLY).
- CONFIDENCE must be a float 0.00-1.00.
- DETAIL must cite concrete code tokens/operations from the function (e.g., "for item in my_list", "my_list.append()").
- If uncertain, output VERDICT: OK with lower confidence.
- Do NOT include any other text.

DANGEROUS pattern to find:
```python
for item in my_list:      # Iterating over my_list
    my_list.append(...)   # Growing THE SAME my_list - DANGEROUS!
```

The variable name after "for item in" MUST match the variable name before ".append()".

SAFE patterns (respond with OK):
- `for x in list_a:` with `list_b.append()` - Different variables, SAFE
- `for x in items:` with `items[x] = val` - Modifying elements, not growing, SAFE

<|im_end|>
<|im_start|>user
Check "Growing Containers" with keyword "GROWING_CONTAINER".

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
solution_prompt = """<|im_start|>system
You are an expert performance engineer. Produce a minimal, correct patch.

Hard constraints:
- Output MUST contain exactly one ```diff fenced block and nothing else.
- The diff must apply to the provided function as-is.
- Do NOT reference variables that are not defined in the shown context.
- Do NOT introduce syntax errors.
- Do NOT change semantics unless explicitly required by the issue (e.g. do not replace index_add_ with += if indices may repeat).
- If a safe fix is not possible without larger refactor, output an empty diff that changes only a comment explaining why.

<|im_end|>
<|im_start|>user
Issue keyword: GROWING_CONTAINER

Function:
```python
{function_source}
```

<|im_end|>
<|im_start|>assistant
"""
verifier_prompt = """<|im_start|>system
You are a strict patch verifier.

Input:
- ORIGINAL FUNCTION
- PROPOSED DIFF

Output exactly:
VERDICT: VALID | INVALID
REASON: <one short reason, concrete>
END

INVALID if:
- diff block missing
- removed lines do not exist in original
- introduces syntax errors (obvious)
- references undefined variables
- changes meaning in risky ways (e.g. index_add_ -> += with potentially duplicate indices)

Do not add anything else.
<|im_end|>
<|im_start|>user
Original function:
```python
{function_source}
```

Proposed solution:
{solution}

Is this valid? Output VERDICT:, REASON:, END.
<|im_end|>
<|im_start|>assistant
"""
